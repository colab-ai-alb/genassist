/**
 * Refactored preprocessing configuration system
 * Uses a step-based approach where preprocessing steps can be added dynamically
 * Each step is tracked with clear markers in the generated Python code
 */

export type PreprocessingStepType =
  | "column_filter"
  | "missing_value_handling"
  | "outlier_handling"
  | "categorical_encoding"
  | "feature_engineering";

export interface PreprocessingStep {
  id: string; // Unique identifier for this step
  type: PreprocessingStepType;
  enabled: boolean;
  config: StepConfig;
}

export type StepConfig =
  | ColumnFilterStepConfig
  | MissingValueHandlingStepConfig
  | OutlierHandlingStepConfig
  | CategoricalEncodingStepConfig
  | FeatureEngineeringStepConfig;

export interface PreprocessingConfig {
  steps: PreprocessingStep[]; // Ordered list of preprocessing steps
}

// Column Filter Step
export interface ColumnFilterStepConfig {
  columns: ColumnFilterItem[];
}

export interface ColumnFilterItem {
  name: string;
  selected: boolean;
}

// Missing Value Handling Step
export type MissingValueStrategy =
  | "no_action"
  | "drop_column"
  | "drop_rows"
  | "impute_constant"
  | "impute_mean"
  | "impute_median"
  | "impute_mode";

export interface MissingValueHandlingStepConfig {
  columns: MissingValueHandlingItem[];
}

export interface MissingValueHandlingItem {
  columnName: string;
  missingCount: number;
  missingPercentage: number;
  strategy: MissingValueStrategy;
  imputeValue?: string | number;
}

// Outlier Handling Step
export type OutlierStrategy = "no_action" | "remove_outliers" | "cap_outliers";
export type OutlierMethod = "iqr" | "zscore";

export interface OutlierHandlingStepConfig {
  columns: OutlierHandlingItem[];
}

export interface OutlierHandlingItem {
  columnName: string;
  strategy: OutlierStrategy;
  method?: OutlierMethod;
  iqrMultiplier?: number;
  zScoreThreshold?: number;
}

// Categorical Encoding Step
export type CategoricalEncodingStrategy =
  | "no_action"
  | "one_hot"
  | "label"
  | "ordinal";

export interface CategoricalEncodingStepConfig {
  columns: CategoricalEncodingItem[];
}

export interface CategoricalEncodingItem {
  columnName: string;
  strategy: CategoricalEncodingStrategy;
  dropFirst?: boolean;
  ordinalMapping?: Record<string, number>;
}

// Feature Engineering Step
export type FeatureEngineeringStrategy =
  | "custom_expression"
  | "bin_numeric"
  | "normalize"
  | "standardize"
  | "polynomial";

export interface FeatureEngineeringStepConfig {
  features: FeatureEngineeringItem[];
}

export interface FeatureEngineeringItem {
  id: string;
  newColumnName: string;
  strategy: FeatureEngineeringStrategy;
  expression?: string;
  sourceColumns?: string[];
  numBins?: number;
  binColumn?: string;
  polynomialDegree?: number;
  polynomialColumns?: string[];
}

/**
 * Base template for Python preprocessing code
 */
export const BASE_PYTHON_TEMPLATE = `# Generated Python function template
from typing import Optional

# Store your result in the 'result' variable
# Import any additional libraries you need
# import json
# import requests
# import datetime
import pandas as pd

# DO NOT EDIT THIS FUNCTION
def autogenerated_preprocessing_function(df):
    # STEP_MARKER_START: Preprocessing steps will be inserted here
    # STEP_MARKER_END
    return df

def executable_function(params):
    
    # This is loaded dataframe from file path:
    df = params["df"]
    # Apply the autogenerated preprocessing code
    df = autogenerated_preprocessing_function(df)

    #Write your code here

    return df`;

/**
 * Generate Python code from preprocessing configuration
 * Uses step markers to clearly identify each preprocessing step
 */
export function generatePythonCodeFromConfig(
  config: PreprocessingConfig,
  existingCode?: string
): string {
  const codeToModify = existingCode || BASE_PYTHON_TEMPLATE;

  // Find the autogenerated_preprocessing_function
  const autogenMatch = codeToModify.match(
    /def autogenerated_preprocessing_function\(df\):([\s\S]*?)(?=def |$)/
  );

  if (!autogenMatch) {
    return codeToModify;
  }

  const autogenFunctionStart = codeToModify.indexOf(autogenMatch[0]);
  const beforeAutogen = codeToModify.substring(0, autogenFunctionStart);
  const afterAutogen = codeToModify.substring(
    autogenFunctionStart + autogenMatch[0].length
  );

  // Build function body
  const autogenBodyLines: string[] = [];
  
  // Create a copy to avoid SettingWithCopyWarning
  autogenBodyLines.push("    # Create a copy to avoid SettingWithCopyWarning");
  autogenBodyLines.push("    df = df.copy()");
  autogenBodyLines.push("");

  // Track columns that will be dropped (across all steps)
  const columnsToDropSet = new Set<string>();

  // First pass: collect all columns to drop
  config.steps.forEach((step) => {
    if (step.type === "missing_value_handling" && step.enabled) {
      const stepConfig = step.config as MissingValueHandlingStepConfig;
      stepConfig.columns.forEach((item) => {
        if (item.strategy === "drop_column") {
          columnsToDropSet.add(item.columnName);
        }
      });
    }
  });

  // Generate code for each step
  config.steps.forEach((step, index) => {
    if (!step.enabled) return;

    if (index > 0 || autogenBodyLines.length > 3) {
      autogenBodyLines.push("");
    }

    // Step marker with ID and type
    autogenBodyLines.push(`    # STEP_START:${step.id}:${step.type}`);
    
    // Add minimal step configuration as JSON comment for robust parsing
    // Only store data that's ambiguous or hard to parse from code
    try {
      const minimalConfig = extractMinimalConfig(step.type, step.config);
      if (minimalConfig && Object.keys(minimalConfig).length > 0) {
        const configJson = JSON.stringify(minimalConfig);
        autogenBodyLines.push(`    # STEP_CONFIG:${configJson}`);
      }
    } catch (e) {
      console.error("Failed to serialize step config:", e);
    }
    
    switch (step.type) {
      case "column_filter":
        generateColumnFilterCode(step.config as ColumnFilterStepConfig, autogenBodyLines);
        break;
      case "missing_value_handling":
        generateMissingValueHandlingCode(
          step.config as MissingValueHandlingStepConfig,
          autogenBodyLines,
          columnsToDropSet
        );
        break;
      case "outlier_handling":
        generateOutlierHandlingCode(
          step.config as OutlierHandlingStepConfig,
          autogenBodyLines,
          columnsToDropSet
        );
        break;
      case "categorical_encoding":
        generateCategoricalEncodingCode(
          step.config as CategoricalEncodingStepConfig,
          autogenBodyLines,
          columnsToDropSet
        );
        break;
      case "feature_engineering":
        generateFeatureEngineeringCode(
          step.config as FeatureEngineeringStepConfig,
          autogenBodyLines
        );
        break;
    }
    
    autogenBodyLines.push(`    # STEP_END:${step.id}:${step.type}`);
  });

  // If no steps, add placeholder
  if (config.steps.length === 0) {
    autogenBodyLines.push("    # No preprocessing steps configured");
  }

  autogenBodyLines.push("");
  autogenBodyLines.push("    return df");

  const newAutogenFunction = `def autogenerated_preprocessing_function(df):\n${autogenBodyLines.join("\n")}\n`;
  return beforeAutogen + newAutogenFunction + afterAutogen;
}

// Extract minimal config - only data that's ambiguous when parsing from code
function extractMinimalConfig(
  stepType: PreprocessingStepType,
  config: StepConfig
): Record<string, unknown> | null {
  switch (stepType) {
    case "column_filter": {
      const colConfig = config as ColumnFilterStepConfig;
      // Only store selected columns - can parse the rest from code
      return {
        selectedColumns: colConfig.columns
          .filter((c) => c.selected)
          .map((c) => c.name),
      };
    }
    case "missing_value_handling": {
      const mvConfig = config as MissingValueHandlingStepConfig;
      // Only store strategy and imputeValue - missingCount/percentage can be recalculated
      return {
        columns: mvConfig.columns.map((col) => ({
          columnName: col.columnName,
          strategy: col.strategy,
          imputeValue: col.imputeValue, // Critical: preserves string vs number
        })),
      };
    }
    case "outlier_handling": {
      const outConfig = config as OutlierHandlingStepConfig;
      // Store strategy, method, and parameters
      return {
        columns: outConfig.columns.map((col) => ({
          columnName: col.columnName,
          strategy: col.strategy,
          method: col.method,
          iqrMultiplier: col.iqrMultiplier,
          zScoreThreshold: col.zScoreThreshold,
        })),
      };
    }
    case "categorical_encoding": {
      const catConfig = config as CategoricalEncodingStepConfig;
      // Store strategy and parameters
      return {
        columns: catConfig.columns.map((col) => ({
          columnName: col.columnName,
          strategy: col.strategy,
          dropFirst: col.dropFirst,
        })),
      };
    }
    case "feature_engineering": {
      const feConfig = config as FeatureEngineeringStepConfig;
      // Store the features array
      return {
        features: feConfig.features,
      };
    }
    default:
      return null;
  }
}

// Restore full config from minimal config and parsed code data
function restoreConfigFromMinimal(
  stepType: PreprocessingStepType,
  minimalConfig: Record<string, unknown>,
  parsedConfig: StepConfig | null
): StepConfig | null {
  if (!parsedConfig) return null;

  switch (stepType) {
    case "column_filter": {
      const parsed = parsedConfig as ColumnFilterStepConfig;
      const minimal = minimalConfig as { selectedColumns?: string[] };
      if (minimal.selectedColumns) {
        // Merge: use selectedColumns from minimal, keep all columns from parsed
        const selectedSet = new Set(minimal.selectedColumns);
        return {
          columns: parsed.columns.map((col) => ({
            ...col,
            selected: selectedSet.has(col.name),
          })),
        };
      }
      return parsed;
    }
    case "missing_value_handling": {
      const parsed = parsedConfig as MissingValueHandlingStepConfig;
      const minimal = minimalConfig as {
        columns?: Array<{
          columnName: string;
          strategy: MissingValueStrategy;
          imputeValue?: string | number;
        }>;
      };
      if (minimal.columns) {
        // Use minimal config as source of truth for columns, strategies, and imputeValues
        // Only use parsed data to fill in missingCount/percentage if available
        const parsedMap = new Map(
          parsed.columns.map((c) => [c.columnName, c])
        );
        
        // Build columns from minimal config (source of truth)
        const mergedColumns: MissingValueHandlingItem[] = minimal.columns.map((minimalCol) => {
          const parsedCol = parsedMap.get(minimalCol.columnName);
          // Use parsed data for missingCount/percentage if available, otherwise default to 0
          return {
            columnName: minimalCol.columnName,
            missingCount: parsedCol?.missingCount ?? 0,
            missingPercentage: parsedCol?.missingPercentage ?? 0,
            strategy: minimalCol.strategy,
            imputeValue: minimalCol.imputeValue,
          };
        });
        
        return {
          columns: mergedColumns,
        };
      }
      return parsed;
    }
    case "outlier_handling": {
      const parsed = parsedConfig as OutlierHandlingStepConfig;
      const minimal = minimalConfig as {
        columns?: Array<{
          columnName: string;
          strategy: OutlierStrategy;
          method?: OutlierMethod;
          iqrMultiplier?: number;
          zScoreThreshold?: number;
        }>;
      };
      if (minimal.columns) {
        // Use minimal config as source of truth for columns, strategies, methods, and parameters
        // Build columns from minimal config (source of truth)
        const mergedColumns: OutlierHandlingItem[] = minimal.columns.map((minimalCol) => {
          return {
            columnName: minimalCol.columnName,
            strategy: minimalCol.strategy,
            method: minimalCol.method,
            iqrMultiplier: minimalCol.iqrMultiplier,
            zScoreThreshold: minimalCol.zScoreThreshold,
          };
        });
        
        return {
          columns: mergedColumns,
        };
      }
      return parsed;
    }
    case "categorical_encoding": {
      const parsed = parsedConfig as CategoricalEncodingStepConfig;
      const minimal = minimalConfig as {
        columns?: Array<{
          columnName: string;
          strategy: CategoricalEncodingStrategy;
          dropFirst?: boolean;
        }>;
      };
      if (minimal.columns) {
        // Use minimal config as source of truth for columns, strategies, and parameters
        // Only use parsed data to fill in ordinalMapping if available
        const parsedMap = new Map(
          parsed.columns.map((c) => [c.columnName, c])
        );
        
        // Build columns from minimal config (source of truth)
        const mergedColumns: CategoricalEncodingItem[] = minimal.columns.map((minimalCol) => {
          const parsedCol = parsedMap.get(minimalCol.columnName);
          return {
            columnName: minimalCol.columnName,
            strategy: minimalCol.strategy,
            dropFirst: minimalCol.dropFirst,
            ordinalMapping: parsedCol?.ordinalMapping, // Keep ordinalMapping from parsed if available
          };
        });
        
        return {
          columns: mergedColumns,
        };
      }
      return parsed;
    }
    case "feature_engineering": {
      const minimal = minimalConfig as { features?: FeatureEngineeringItem[] };
      if (minimal.features) {
        return { features: minimal.features };
      }
      return parsedConfig;
    }
    default:
      return parsedConfig;
  }
}

// Code generation helpers
function generateColumnFilterCode(
  config: ColumnFilterStepConfig,
  lines: string[]
): void {
  const selectedColumns = config.columns
      .filter((col) => col.selected && col.name.trim().length > 0)
      .map((col) => `"${col.name.trim()}"`)
      .join(", ");

    if (selectedColumns) {
    lines.push("    # Filter columns");
    lines.push(`    df = df[[${selectedColumns}]]`);
  }
}

function generateMissingValueHandlingCode(
  config: MissingValueHandlingStepConfig,
  lines: string[],
  columnsToDrop: Set<string>
): void {
  lines.push("    # Handle missing values");

  const columnsToDropList: string[] = [];
  const columnsToImpute: Array<{
    column: string;
    strategy: MissingValueStrategy;
    value?: string | number;
  }> = [];

  config.columns.forEach((item) => {
    if (item.strategy === "no_action") return;
    
    if (item.strategy === "drop_column") {
      columnsToDropList.push(item.columnName);
    } else if (item.strategy === "drop_rows") {
      lines.push(`    if "${item.columnName}" in df.columns:`);
      lines.push(`        df = df.dropna(subset=["${item.columnName}"])`);
    } else {
      if (!columnsToDrop.has(item.columnName)) {
        columnsToImpute.push({
          column: item.columnName,
          strategy: item.strategy,
          value: item.imputeValue,
        });
      }
    }
  });

  if (columnsToDropList.length > 0) {
    lines.push(`    df = df.drop(columns=[${columnsToDropList.map((c) => `"${c}"`).join(", ")}], errors='ignore')`);
  }

  columnsToImpute.forEach((item) => {
    lines.push(`    if "${item.column}" in df.columns:`);
    if (item.strategy === "impute_constant") {
      let valueStr: string;
      if (item.value === undefined || item.value === null) {
        valueStr = "0";
      } else if (typeof item.value === "string") {
        const numValue = parseFloat(item.value);
        if (!isNaN(numValue) && numValue.toString() === item.value) {
          valueStr = numValue.toString();
        } else {
          valueStr = `"${item.value.replace(/"/g, '\\"')}"`;
        }
      } else {
        valueStr = item.value.toString();
      }
      // Add comment with impute value for state preservation
      const imputeValueJson = JSON.stringify(item.value ?? "0");
      lines.push(`        # IMPUTE_VALUE:${item.column}:${imputeValueJson}`);
      lines.push(`        df.loc[:, "${item.column}"] = df["${item.column}"].fillna(${valueStr})`);
    } else if (item.strategy === "impute_mean") {
      lines.push(`        df.loc[:, "${item.column}"] = df["${item.column}"].fillna(df["${item.column}"].mean())`);
    } else if (item.strategy === "impute_median") {
      lines.push(`        df.loc[:, "${item.column}"] = df["${item.column}"].fillna(df["${item.column}"].median())`);
    } else if (item.strategy === "impute_mode") {
      lines.push(`        df.loc[:, "${item.column}"] = df["${item.column}"].fillna(df["${item.column}"].mode()[0] if len(df["${item.column}"].mode()) > 0 else None)`);
    }
  });
}

function generateOutlierHandlingCode(
  config: OutlierHandlingStepConfig,
  lines: string[],
  columnsToDrop: Set<string>
): void {
  lines.push("    # Handle outliers");

  config.columns.forEach((item) => {
    if (item.strategy === "no_action" || columnsToDrop.has(item.columnName)) {
      return;
    }

    lines.push(`    if "${item.columnName}" in df.columns:`);
    const method = item.method || "iqr";
    const iqrMultiplier = item.iqrMultiplier ?? 1.5;
    const zScoreThreshold = item.zScoreThreshold ?? 3;

    if (method === "iqr") {
      lines.push(`        # Handle outliers in ${item.columnName} using IQR method`);
      lines.push(`        Q1 = df["${item.columnName}"].quantile(0.25)`);
      lines.push(`        Q3 = df["${item.columnName}"].quantile(0.75)`);
      lines.push(`        IQR = Q3 - Q1`);
      lines.push(`        lower_bound = Q1 - ${iqrMultiplier} * IQR`);
      lines.push(`        upper_bound = Q3 + ${iqrMultiplier} * IQR`);

      if (item.strategy === "remove_outliers") {
        lines.push(`        df = df[(df["${item.columnName}"] >= lower_bound) & (df["${item.columnName}"] <= upper_bound)]`);
      } else if (item.strategy === "cap_outliers") {
        lines.push(`        df.loc[:, "${item.columnName}"] = df["${item.columnName}"].clip(lower=lower_bound, upper=upper_bound)`);
      }
    } else if (method === "zscore") {
      lines.push(`        # Handle outliers in ${item.columnName} using Z-score method`);
      lines.push(`        mean = df["${item.columnName}"].mean()`);
      lines.push(`        std = df["${item.columnName}"].std()`);
      lines.push(`        z_scores = (df["${item.columnName}"] - mean) / std`);

      if (item.strategy === "remove_outliers") {
        lines.push(`        df = df[(z_scores.abs() <= ${zScoreThreshold})]`);
      } else if (item.strategy === "cap_outliers") {
        lines.push(`        lower_bound = mean - ${zScoreThreshold} * std`);
        lines.push(`        upper_bound = mean + ${zScoreThreshold} * std`);
        lines.push(`        df.loc[:, "${item.columnName}"] = df["${item.columnName}"].clip(lower=lower_bound, upper=upper_bound)`);
      }
    }
  });
}

function generateCategoricalEncodingCode(
  config: CategoricalEncodingStepConfig,
  lines: string[],
  columnsToDrop: Set<string>
): void {
  lines.push("    # Encode categorical columns");

  config.columns.forEach((item) => {
    if (item.strategy === "no_action" || columnsToDrop.has(item.columnName)) {
      return;
    }

    lines.push(`    if "${item.columnName}" in df.columns:`);
    if (item.strategy === "one_hot") {
      const dropFirst = item.dropFirst ?? false;
      lines.push(`        # One-hot encode ${item.columnName}`);
      if (dropFirst) {
        lines.push(`        df = pd.get_dummies(df, columns=["${item.columnName}"], prefix="${item.columnName}", drop_first=True)`);
      } else {
        lines.push(`        df = pd.get_dummies(df, columns=["${item.columnName}"], prefix="${item.columnName}")`);
      }
    } else if (item.strategy === "label") {
      lines.push(`        # Label encode ${item.columnName}`);
      lines.push(`        df.loc[:, "${item.columnName}"] = df["${item.columnName}"].astype('category').cat.codes`);
    } else if (item.strategy === "ordinal") {
      if (item.ordinalMapping && Object.keys(item.ordinalMapping).length > 0) {
        lines.push(`        # Ordinal encode ${item.columnName}`);
        lines.push(`        mapping = ${JSON.stringify(item.ordinalMapping)}`);
        lines.push(`        df.loc[:, "${item.columnName}"] = df["${item.columnName}"].map(mapping)`);
      }
    }
  });
}

function generateFeatureEngineeringCode(
  config: FeatureEngineeringStepConfig,
  lines: string[]
): void {
  lines.push("    # Feature engineering");

  config.features.forEach((item) => {
    if (item.strategy === "custom_expression" && item.expression && item.newColumnName) {
      lines.push(`    # Create feature: ${item.newColumnName}`);
      lines.push(`    df["${item.newColumnName}"] = ${item.expression}`);
    } else if (item.strategy === "bin_numeric" && item.binColumn && item.numBins) {
      lines.push(`    # Bin numeric column: ${item.binColumn}`);
      lines.push(`    if "${item.binColumn}" in df.columns:`);
      lines.push(`        # Check if column is numeric before binning`);
      lines.push(`        if pd.api.types.is_numeric_dtype(df["${item.binColumn}"]):`);
      lines.push(`            df["${item.newColumnName}"] = pd.cut(df["${item.binColumn}"], bins=${item.numBins}, labels=False, duplicates='drop')`);
    } else if (item.strategy === "normalize" && item.sourceColumns && item.sourceColumns.length > 0) {
      lines.push(`    # Normalize columns: ${item.sourceColumns.join(", ")}`);
      item.sourceColumns.forEach((col) => {
        lines.push(`    if "${col}" in df.columns:`);
        lines.push(`        # Check if column is numeric before normalizing`);
        lines.push(`        if pd.api.types.is_numeric_dtype(df["${col}"]):`);
        lines.push(`            min_val = df["${col}"].min()`);
        lines.push(`            max_val = df["${col}"].max()`);
        lines.push(`            if max_val != min_val:`);
        lines.push(`                df["${item.newColumnName || col + "_normalized"}"] = (df["${col}"] - min_val) / (max_val - min_val)`);
      });
    } else if (item.strategy === "standardize" && item.sourceColumns && item.sourceColumns.length > 0) {
      lines.push(`    # Standardize columns: ${item.sourceColumns.join(", ")}`);
      item.sourceColumns.forEach((col) => {
        lines.push(`    if "${col}" in df.columns:`);
        lines.push(`        # Check if column is numeric before standardizing`);
        lines.push(`        if pd.api.types.is_numeric_dtype(df["${col}"]):`);
        lines.push(`            mean_val = df["${col}"].mean()`);
        lines.push(`            std_val = df["${col}"].std()`);
        lines.push(`            if std_val != 0:`);
        lines.push(`                df["${item.newColumnName || col + "_standardized"}"] = (df["${col}"] - mean_val) / std_val`);
      });
    } else if (item.strategy === "polynomial" && item.polynomialColumns && item.polynomialColumns.length > 0 && item.polynomialDegree) {
      lines.push(`    # Create polynomial features from: ${item.polynomialColumns.join(", ")}`);
      lines.push(`    from sklearn.preprocessing import PolynomialFeatures`);
      lines.push(`    # Filter to only numeric columns`);
      lines.push(`    poly_cols = [col for col in ${JSON.stringify(item.polynomialColumns)} if col in df.columns and pd.api.types.is_numeric_dtype(df[col])]`);
      lines.push(`    if len(poly_cols) > 0:`);
      lines.push(`        poly = PolynomialFeatures(degree=${item.polynomialDegree}, include_bias=False)`);
      lines.push(`        poly_features = poly.fit_transform(df[poly_cols])`);
      lines.push(`        poly_df = pd.DataFrame(poly_features, columns=poly.get_feature_names_out(poly_cols), index=df.index)`);
      lines.push(`        df = pd.concat([df, poly_df], axis=1)`);
    }
  });
}

/**
 * Parse Python code to extract preprocessing configuration
 * Uses step markers to identify and parse each step
 */
export function parsePythonCodeToConfig(code: string): PreprocessingConfig {
  const config: PreprocessingConfig = { steps: [] };

  // Extract autogenerated_preprocessing_function function body
  const autogenMatch = code.match(/def autogenerated_preprocessing_function\(df\):([\s\S]*?)(?=def |$)/);
  if (!autogenMatch) {
    return config;
  }

  const codeToParse = autogenMatch[1];

  // Find all step markers
  const stepPattern = /# STEP_START:([^:]+):([^\n]+)([\s\S]*?)# STEP_END:\1:\2/g;
  let match;
  
  while ((match = stepPattern.exec(codeToParse)) !== null) {
    const stepId = match[1];
    const stepType = match[2] as PreprocessingStepType;
    const stepCode = match[3];

    let stepConfig: StepConfig | null = null;

    // First, parse from code to get base structure
    let parsedFromCode: StepConfig | null = null;
    switch (stepType) {
      case "column_filter":
        parsedFromCode = parseColumnFilterStep(stepCode);
        break;
      case "missing_value_handling":
        parsedFromCode = parseMissingValueHandlingStep(stepCode);
        break;
      case "outlier_handling":
        parsedFromCode = parseOutlierHandlingStep(stepCode);
        break;
      case "categorical_encoding":
        parsedFromCode = parseCategoricalEncodingStep(stepCode);
        break;
      case "feature_engineering":
        parsedFromCode = parseFeatureEngineeringStep(stepCode);
        break;
    }

    // Then, try to merge with minimal config from comment if available
    const configCommentMatch = stepCode.match(/#\s*STEP_CONFIG:(.+?)(?=\n\s*#|$)/s);
    if (configCommentMatch) {
      try {
        const configJson = configCommentMatch[1].trim();
        const minimalConfig = JSON.parse(configJson) as Record<string, unknown>;
        // Restore full config by merging minimal config with parsed code
        stepConfig = restoreConfigFromMinimal(stepType, minimalConfig, parsedFromCode);
      } catch (e) {
        console.warn(`Failed to parse STEP_CONFIG for ${stepType}:`, e);
        // Fall back to parsed code only
        stepConfig = parsedFromCode;
      }
    } else {
      // No comment, use parsed code only
      stepConfig = parsedFromCode;
    }

    if (stepConfig) {
      config.steps.push({
        id: stepId,
        type: stepType,
        enabled: true, // If step marker exists, it's enabled
        config: stepConfig,
      });
    }
  }

  // Fallback: try to parse without markers (for backward compatibility)
  if (config.steps.length === 0) {
    // Try legacy parsing
    const legacyConfig = parseLegacyCode(code);
    if (legacyConfig.steps.length > 0) {
      return legacyConfig;
    }
  }

  return config;
}

// Step parsing helpers
function parseColumnFilterStep(code: string): ColumnFilterStepConfig | null {
  // Look for column filter pattern within step code
  const pattern = /df\s*=\s*df\[\[([^\]]+)\]\]/;
  const match = code.match(pattern);
  if (!match) return null;

        const columnNames = match[1]
          .split(",")
          .map((col) => col.trim().replace(/^["']|["']$/g, ""))
          .filter((col) => col.length > 0);

  if (columnNames.length === 0) return null;

  return {
    columns: columnNames.map((name) => ({ name, selected: true })),
  };
}

function parseMissingValueHandlingStep(code: string): MissingValueHandlingStepConfig | null {
  const items: MissingValueHandlingItem[] = [];
  const processedColumns = new Set<string>(); // Track which columns have been processed

  // First, extract impute values from comments (more reliable)
  const imputeValueComments: Map<string, string | number> = new Map();
  const imputeCommentPattern = /#\s*IMPUTE_VALUE:([^:]+):(.+)/g;
  let commentMatch;
  while ((commentMatch = imputeCommentPattern.exec(code)) !== null) {
    const columnName = commentMatch[1].trim();
    try {
      const value = JSON.parse(commentMatch[2].trim());
      imputeValueComments.set(columnName, value);
    } catch (e) {
      // If JSON parse fails, treat as string
      imputeValueComments.set(columnName, commentMatch[2].trim());
    }
  }

  // Drop rows - must check before impute to avoid conflicts
  const dropRowsPattern = /if\s+"([^"]+)"\s+in\s+df\.columns:[\s\S]*?df\s*=\s*df\.dropna\(subset\s*=\s*\["([^"]+)"\]\)/g;
  let match;
  while ((match = dropRowsPattern.exec(code)) !== null) {
    const columnName = match[1];
    if (!processedColumns.has(columnName)) {
      items.push({
        columnName,
        missingCount: 0,
        missingPercentage: 0,
        strategy: "drop_rows",
      });
      processedColumns.add(columnName);
    }
  }

  // Drop columns
  const dropColumnPattern = /df\s*=\s*df\.drop\(columns\s*=\s*\[([^\]]+)\]/g;
  while ((match = dropColumnPattern.exec(code)) !== null) {
    const columns = match[1]
      .split(",")
      .map((c) => c.trim().replace(/^["']|["']$/g, ""));
    columns.forEach((col) => {
      if (!processedColumns.has(col)) {
        items.push({
          columnName: col,
          missingCount: 0,
          missingPercentage: 0,
          strategy: "drop_column",
        });
        processedColumns.add(col);
      }
    });
  }

  // Impute operations - only match if it's actually a fillna operation, not dropna
  // Pattern must ensure it's df.loc[:, "..."] = df["..."].fillna(...) and NOT dropna
  const imputePattern = /if\s+"([^"]+)"\s+in\s+df\.columns:[\s\S]*?(?:#\s*IMPUTE_VALUE:[^:]+:[^\n]+\n\s*)?df\.loc\[:,\s*"([^"]+)"\]\s*=\s*df\["([^"]+)"\]\.fillna\(([^)]+)\)/g;
  while ((match = imputePattern.exec(code)) !== null) {
    const columnName = match[1];
    // Skip if already processed (as drop_rows or drop_column)
    if (processedColumns.has(columnName)) {
      continue;
    }
    
    const valueStr = match[4].trim();
    
    let strategy: MissingValueStrategy = "impute_constant";
    let imputeValue: string | number | undefined;

    if (valueStr.includes(".mean()")) {
      strategy = "impute_mean";
    } else if (valueStr.includes(".median()")) {
      strategy = "impute_median";
    } else if (valueStr.includes(".mode()")) {
      strategy = "impute_mode";
    } else {
      // First, try to get value from comment (most reliable)
      if (imputeValueComments.has(columnName)) {
        imputeValue = imputeValueComments.get(columnName);
      } else {
        // Fallback to parsing from code
        // Check if value is quoted (string) or unquoted (number)
        const hasQuotes = (valueStr.startsWith('"') && valueStr.endsWith('"')) || 
                          (valueStr.startsWith("'") && valueStr.endsWith("'"));
        
        if (hasQuotes) {
          // Quoted value - treat as string
          imputeValue = valueStr.slice(1, -1); // Remove quotes
        } else {
          // Unquoted value - try to parse as number
          const trimmed = valueStr.trim();
          const numValue = parseFloat(trimmed);
          
          if (!isNaN(numValue) && isFinite(numValue)) {
            // Check if the trimmed string exactly represents this number
            // This handles "0", "5", "10.5", "-3", etc.
            const numStr = numValue.toString();
            const numStrWithDecimal = numValue % 1 === 0 ? numStr : numValue.toFixed(10).replace(/\.?0+$/, "");
            
            if (trimmed === numStr || trimmed === numStrWithDecimal || 
                parseFloat(trimmed) === numValue && trimmed.match(/^-?\d+(\.\d+)?$/)) {
              imputeValue = numValue;
            } else {
              // Looks like a number but has extra characters, treat as string
              imputeValue = trimmed;
            }
          } else {
            // Not a valid number, treat as string
            imputeValue = trimmed;
          }
        }
      }
      
      // Ensure impute_constant always has a value
      if (imputeValue === undefined || imputeValue === null || 
          (typeof imputeValue === "string" && imputeValue === "")) {
        imputeValue = "0";
      }
    }

    items.push({
      columnName,
      missingCount: 0,
      missingPercentage: 0,
      strategy,
      imputeValue,
    });
    processedColumns.add(columnName);
  }

  return items.length > 0 ? { columns: items } : null;
}

function parseOutlierHandlingStep(code: string): OutlierHandlingStepConfig | null {
  const items: OutlierHandlingItem[] = [];

  // IQR method
  const iqrPattern = /if\s+"([^"]+)"\s+in\s+df\.columns:[\s\S]*?Q1\s*=\s*df\["([^"]+)"\]\.quantile\(0\.25\)[\s\S]*?lower_bound\s*=\s*Q1\s*-\s*([\d.]+)\s*\*\s*IQR/g;
  let match;
  while ((match = iqrPattern.exec(code)) !== null) {
    const columnName = match[1];
    const multiplier = parseFloat(match[3]);
    const afterCode = code.substring(match.index + match[0].length, match.index + match[0].length + 100);
    
    let strategy: OutlierStrategy = "no_action";
    if (afterCode.includes("df = df[(")) {
      strategy = "remove_outliers";
    } else if (afterCode.includes(".clip(")) {
      strategy = "cap_outliers";
    }

    items.push({
      columnName,
      strategy,
      method: "iqr",
      iqrMultiplier: multiplier,
    });
  }

  // Z-score method
  const zscorePattern = /if\s+"([^"]+)"\s+in\s+df\.columns:[\s\S]*?z_scores\s*=\s*\(df\["([^"]+)"\]\s*-\s*mean\)\s*\/\s*std/g;
  while ((match = zscorePattern.exec(code)) !== null) {
    const columnName = match[1];
    const afterCode = code.substring(match.index + match[0].length, match.index + match[0].length + 100);
    const thresholdMatch = afterCode.match(/z_scores\.abs\(\)\s*<=\s*([\d.]+)/);
    const threshold = thresholdMatch ? parseFloat(thresholdMatch[1]) : 3;
    
    let strategy: OutlierStrategy = "no_action";
    if (afterCode.includes("df = df[(")) {
      strategy = "remove_outliers";
    } else if (afterCode.includes(".clip(")) {
      strategy = "cap_outliers";
    }

    items.push({
      columnName,
      strategy,
      method: "zscore",
      zScoreThreshold: threshold,
    });
  }

  return items.length > 0 ? { columns: items } : null;
}

function parseCategoricalEncodingStep(code: string): CategoricalEncodingStepConfig | null {
  const items: CategoricalEncodingItem[] = [];

  // One-hot encoding
  const oneHotPattern = /if\s+"([^"]+)"\s+in\s+df\.columns:[\s\S]*?pd\.get_dummies\(df,\s*columns\s*=\s*\["([^"]+)"\][\s\S]*?prefix\s*=\s*"([^"]+)"(?:,\s*drop_first\s*=\s*True)?\)/g;
  let match;
  while ((match = oneHotPattern.exec(code)) !== null) {
    items.push({
      columnName: match[1],
      strategy: "one_hot",
      dropFirst: match[0].includes("drop_first=True"),
    });
  }

  // Label encoding
  const labelPattern = /if\s+"([^"]+)"\s+in\s+df\.columns:[\s\S]*?df\.loc\[:,\s*"([^"]+)"\]\s*=\s*df\["([^"]+)"\]\.astype\(['"]category['"]\)\.cat\.codes/g;
  while ((match = labelPattern.exec(code)) !== null) {
    items.push({
      columnName: match[1],
      strategy: "label",
    });
  }

  // Ordinal encoding
  const ordinalPattern = /mapping\s*=\s*(\{[^}]+\})[\s\S]*?df\.loc\[:,\s*"([^"]+)"\]\s*=\s*df\["([^"]+)"\]\.map\(mapping\)/g;
  while ((match = ordinalPattern.exec(code)) !== null) {
    try {
      const mapping = JSON.parse(match[1]);
      items.push({
        columnName: match[2],
        strategy: "ordinal",
        ordinalMapping: mapping,
      });
    } catch (e) {
      // Skip if parsing fails
    }
  }

  return items.length > 0 ? { columns: items } : null;
}

function parseFeatureEngineeringStep(code: string): FeatureEngineeringStepConfig | null {
  const items: FeatureEngineeringItem[] = [];

  // Custom expression
  const customPattern = /# Create feature:\s*([^\n]+)[\s\S]*?df\["([^"]+)"\]\s*=\s*([^\n]+)/g;
  let match;
  while ((match = customPattern.exec(code)) !== null) {
    const newColumnName = match[2];
    const expression = match[3].trim();
    if (expression && !expression.includes('df["' + newColumnName + '"]')) {
      items.push({
        id: `custom_${newColumnName}_${Date.now()}`,
        newColumnName,
        strategy: "custom_expression",
        expression,
      });
    }
  }

  // Bin numeric
  const binPattern = /# Bin numeric column:\s*([^\n]+)[\s\S]*?if\s+"([^"]+)"\s+in\s+df\.columns:[\s\S]*?df\["([^"]+)"\]\s*=\s*pd\.cut\(df\["([^"]+)"\],\s*bins\s*=\s*(\d+)/g;
  while ((match = binPattern.exec(code)) !== null) {
    items.push({
      id: `bin_${match[3]}_${Date.now()}`,
      newColumnName: match[3],
      strategy: "bin_numeric",
      binColumn: match[4],
      numBins: parseInt(match[5], 10),
    });
  }

  // Normalize
  const normalizeSection = code.match(/# Normalize columns:\s*([^\n]+)([\s\S]*?)(?=# |$)/);
  if (normalizeSection) {
    const normalizeOps = normalizeSection[2].matchAll(/if\s+"([^"]+)"\s+in\s+df\.columns:[\s\S]*?df\["([^"]+)"\]\s*=\s*\(df\["([^"]+)"\]\s*-\s*min_val\)\s*\/\s*\(max_val\s*-\s*min_val\)/g);
    const normalizeMap = new Map<string, string[]>();
    const autoGeneratedCols: string[] = [];
    
    for (const op of normalizeOps) {
      const sourceCol = op[1];
      const newCol = op[2];
      const expectedAutoName = sourceCol + "_normalized";
      
      if (newCol === expectedAutoName) {
        autoGeneratedCols.push(sourceCol);
      } else {
        if (!normalizeMap.has(newCol)) {
          normalizeMap.set(newCol, []);
        }
        normalizeMap.get(newCol)!.push(sourceCol);
      }
    }
    
    if (autoGeneratedCols.length > 0) {
      items.push({
        id: `normalize_auto_${Date.now()}`,
        newColumnName: "",
        strategy: "normalize",
        sourceColumns: autoGeneratedCols,
      });
    }
    
    normalizeMap.forEach((sourceCols, newCol) => {
      items.push({
        id: `normalize_${newCol}_${Date.now()}`,
        newColumnName: newCol,
        strategy: "normalize",
        sourceColumns: sourceCols,
      });
    });
  }

  // Standardize
  const standardizeSection = code.match(/# Standardize columns:\s*([^\n]+)([\s\S]*?)(?=# |$)/);
  if (standardizeSection) {
    const standardizeOps = standardizeSection[2].matchAll(/if\s+"([^"]+)"\s+in\s+df\.columns:[\s\S]*?df\["([^"]+)"\]\s*=\s*\(df\["([^"]+)"\]\s*-\s*mean_val\)\s*\/\s*std_val/g);
    const standardizeMap = new Map<string, string[]>();
    const autoGeneratedCols: string[] = [];
    
    for (const op of standardizeOps) {
      const sourceCol = op[1];
      const newCol = op[2];
      const expectedAutoName = sourceCol + "_standardized";
      
      if (newCol === expectedAutoName) {
        autoGeneratedCols.push(sourceCol);
      } else {
        if (!standardizeMap.has(newCol)) {
          standardizeMap.set(newCol, []);
        }
        standardizeMap.get(newCol)!.push(sourceCol);
      }
    }
    
    if (autoGeneratedCols.length > 0) {
      items.push({
        id: `standardize_auto_${Date.now()}`,
        newColumnName: "",
        strategy: "standardize",
        sourceColumns: autoGeneratedCols,
      });
    }
    
    standardizeMap.forEach((sourceCols, newCol) => {
      items.push({
        id: `standardize_${newCol}_${Date.now()}`,
        newColumnName: newCol,
        strategy: "standardize",
        sourceColumns: sourceCols,
      });
    });
  }

  // Polynomial
  const polyPattern = /# Create polynomial features from:\s*([^\n]+)[\s\S]*?poly_cols\s*=\s*\[col\s+for\s+col\s+in\s+(\[[^\]]+\])\s+if\s+col\s+in\s+df\.columns\][\s\S]*?poly\s*=\s*PolynomialFeatures\(degree\s*=\s*(\d+)/g;
  const polyMatch = polyPattern.exec(code);
  if (polyMatch) {
    try {
      const columns = JSON.parse(polyMatch[2]);
      const degree = parseInt(polyMatch[3], 10);
      if (Array.isArray(columns) && columns.length > 0) {
        items.push({
          id: `polynomial_${Date.now()}`,
          newColumnName: "polynomial_features",
          strategy: "polynomial",
          polynomialColumns: columns,
          polynomialDegree: degree,
        });
      }
    } catch (e) {
      // Skip if parsing fails
    }
  }

  return items.length > 0 ? { features: items } : null;
}

/**
 * Legacy parsing for backward compatibility
 */
function parseLegacyCode(code: string): PreprocessingConfig {
  const config: PreprocessingConfig = { steps: [] };
  // This would contain the old parsing logic as fallback
  // For now, return empty config
  return config;
}

/**
 * Create a new preprocessing step
 */
export function createPreprocessingStep(
  type: PreprocessingStepType,
  id?: string
): PreprocessingStep {
  const stepId = id || `step_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  let config: StepConfig;
  switch (type) {
    case "column_filter":
      config = { columns: [] };
      break;
    case "missing_value_handling":
      config = { columns: [] };
      break;
    case "outlier_handling":
      config = { columns: [] };
      break;
    case "categorical_encoding":
      config = { columns: [] };
      break;
    case "feature_engineering":
      config = { features: [] };
      break;
  }

  return {
    id: stepId,
    type,
    enabled: true,
    config,
  };
}

/**
 * Get step type display name
 */
export function getStepTypeDisplayName(type: PreprocessingStepType): string {
  const names: Record<PreprocessingStepType, string> = {
    column_filter: "Column Filter",
    missing_value_handling: "Handle Missing Values",
    outlier_handling: "Handle Outliers",
    categorical_encoding: "Categorical Encoding",
    feature_engineering: "Feature Engineering",
  };
  return names[type] || type;
}

// Legacy config types for component compatibility
export interface ColumnFilterConfig {
  enabled: boolean;
  columns: ColumnFilterItem[];
}

export interface MissingValueHandlingConfig {
  enabled: boolean;
  columns: MissingValueHandlingItem[];
}

export interface OutlierHandlingConfig {
  enabled: boolean;
  columns: OutlierHandlingItem[];
}

export interface CategoricalEncodingConfig {
  enabled: boolean;
  columns: CategoricalEncodingItem[];
}

export interface FeatureEngineeringConfig {
  enabled: boolean;
  features: FeatureEngineeringItem[];
}
